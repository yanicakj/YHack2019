import { range, min, max, descending } from 'd3-array';
import cloud from 'd3-cloud';
import React, { useRef, useState, useEffect } from 'react';
import seedrandom from 'seedrandom';
import { select, event } from 'd3-selection';
import ResizeObserver from 'resize-observer-polyfill';
import 'd3-transition';
import tippy from 'tippy.js';
import { scaleOrdinal, scaleLog, scaleSqrt, scaleLinear } from 'd3-scale';
import { schemeCategory10 } from 'd3-scale-chromatic';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function useResponsiveSVGSelection(minSize, initialSize) {
    var elementRef = useRef();
    var _a = useState(initialSize), size = _a[0], setSize = _a[1];
    var _b = useState(null), selection = _b[0], setSelection = _b[1];
    useEffect(function () {
        var element = elementRef.current;
        // set svg selection
        var svg = select(element)
            .append('svg')
            .style('display', 'block'); // native inline svg leaves undesired white space
        var selection = svg.append('g');
        setSelection(selection);
        function updateSize(width, height) {
            svg.attr('height', height).attr('width', width);
            selection.attr('transform', "translate(" + width / 2 + ", " + height / 2 + ")");
            setSize([width, height]);
        }
        var width = 0;
        var height = 0;
        if (initialSize !== undefined) {
            // Use initialSize if it is provided
            width = initialSize[0], height = initialSize[1];
        }
        else {
            // Use parentNode size if resized has not updated
            width = element.parentElement.offsetWidth;
            height = element.parentElement.offsetHeight;
        }
        width = Math.max(width, minSize[0]);
        height = Math.max(height, minSize[1]);
        updateSize(width, height);
        // update resize using a resize observer
        var resizeObserver = new ResizeObserver(function (entries) {
            if (!entries || !entries.length) {
                return;
            }
            if (initialSize === undefined) {
                var _a = entries[0].contentRect, width_1 = _a.width, height_1 = _a.height;
                updateSize(width_1, height_1);
            }
        });
        resizeObserver.observe(element);
        // cleanup
        return function () {
            resizeObserver.unobserve(element);
            select(element)
                .selectAll('*')
                .remove();
        };
    }, [initialSize, minSize]);
    return [elementRef, selection, size];
}

var Scale;
(function (Scale) {
    Scale["Linear"] = "linear";
    Scale["Log"] = "log";
    Scale["Sqrt"] = "sqrt";
})(Scale || (Scale = {}));
var Spiral;
(function (Spiral) {
    Spiral["Archimedean"] = "archimedean";
    Spiral["Rectangular"] = "rectangular";
})(Spiral || (Spiral = {}));

function choose(array, random) {
    return array[Math.floor(random() * array.length)];
}
function getDefaultColors() {
    return range(20)
        .map(function (number) { return number.toString(); })
        .map(scaleOrdinal(schemeCategory10));
}
function getFontScale(words, fontSizes, scale) {
    var minSize = min(words, function (word) { return word.value; });
    var maxSize = max(words, function (word) { return word.value; });
    var scaleFunction;
    switch (scale) {
        case Scale.Log:
            scaleFunction = scaleLog;
            break;
        case Scale.Sqrt:
            scaleFunction = scaleSqrt;
            break;
        case Scale.Linear:
        default:
            scaleFunction = scaleLinear;
            break;
    }
    var fontScale = scaleFunction()
        .domain([minSize, maxSize])
        .range(fontSizes);
    return fontScale;
}
function getText(word) {
    return word.text;
}
function getFontSize(word) {
    return word.size + "px";
}
function getTransform(word) {
    var translate = "translate(" + word.x + ", " + word.y + ")";
    var rotate = typeof word.rotate === 'number' ? "rotate(" + word.rotate + ")" : '';
    return translate + rotate;
}
function rotate(rotations, rotationAngles, random) {
    if (rotations < 1) {
        return 0;
    }
    var angles = [];
    if (rotations === 1) {
        angles = [rotationAngles[0]];
    }
    else {
        angles = __spreadArrays(rotationAngles);
        var increment = (rotationAngles[1] - rotationAngles[0]) / (rotations - 1);
        var angle = rotationAngles[0] + increment;
        while (angle < rotationAngles[1]) {
            angles.push(angle);
            angle += increment;
        }
    }
    return choose(angles, random);
}

var tooltipInstance;
function render(selection, words, options, callbacks, random) {
    var getWordColor = callbacks.getWordColor, getWordTooltip = callbacks.getWordTooltip, onWordClick = callbacks.onWordClick, onWordMouseOver = callbacks.onWordMouseOver, onWordMouseOut = callbacks.onWordMouseOut;
    var colors = options.colors, enableTooltip = options.enableTooltip, fontStyle = options.fontStyle, fontWeight = options.fontWeight;
    var fontFamily = options.fontFamily, transitionDuration = options.transitionDuration;
    function getFill(word) {
        return getWordColor ? getWordColor(word) : choose(colors, random);
    }
    // load words
    var vizWords = selection.selectAll('text').data(words);
    vizWords.join(function (enter) {
        return enter
            .append('text')
            .on('click', function (word) {
            onWordClick && onWordClick(word, event);
        })
            .on('mouseover', function (word) {
            if (enableTooltip) {
                tooltipInstance = tippy(event.target, {
                    animation: 'scale',
                    arrow: true,
                    content: function () {
                        return getWordTooltip(word);
                    },
                });
            }
            onWordMouseOver && onWordMouseOver(word, event);
        })
            .on('mouseout', function (word) {
            if (tooltipInstance) {
                tooltipInstance.destroy();
            }
            onWordMouseOut && onWordMouseOut(word, event);
        })
            .attr('cursor', onWordClick ? 'pointer' : 'default')
            .attr('fill', getFill)
            .attr('font-family', fontFamily)
            .attr('font-style', fontStyle)
            .attr('font-weight', fontWeight)
            .attr('text-anchor', 'middle')
            .attr('transform', 'translate(0, 0) rotate(0)')
            .call(function (enter) {
            return enter
                .transition()
                .duration(transitionDuration)
                .attr('font-size', getFontSize)
                .attr('transform', getTransform)
                .text(getText);
        });
    }, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function (update) {
        return update
            .transition()
            .duration(transitionDuration)
            .attr('fill', getFill)
            .attr('font-family', fontFamily)
            .attr('font-size', getFontSize)
            .attr('transform', getTransform)
            .text(getText);
    }, function (exit) {
        exit
            .transition()
            .duration(transitionDuration)
            .attr('fill-opacity', 0)
            .remove();
    });
}

var MAX_LAYOUT_ATTEMPTS = 10;
var SHRINK_FACTOR = 0.95;
var defaultCallbacks = {
    getWordTooltip: function (_a) {
        var text = _a.text, value = _a.value;
        return text + " (" + value + ")";
    },
};
var defaultOptions = {
    colors: getDefaultColors(),
    deterministic: false,
    enableTooltip: true,
    fontFamily: 'times new roman',
    fontSizes: [4, 32],
    fontStyle: 'normal',
    fontWeight: 'normal',
    padding: 1,
    rotationAngles: [-90, 90],
    scale: Scale.Sqrt,
    spiral: Spiral.Rectangular,
    transitionDuration: 600,
};
function Wordcloud(_a) {
    var callbacks = _a.callbacks, _b = _a.maxWords, maxWords = _b === void 0 ? 100 : _b, minSize = _a.minSize, options = _a.options, initialSize = _a.size, words = _a.words;
    var mergedCallbacks = __assign(__assign({}, defaultCallbacks), callbacks);
    var mergedOptions = __assign(__assign({}, defaultOptions), options);
    var _c = useResponsiveSVGSelection(minSize, initialSize), ref = _c[0], selection = _c[1], size = _c[2];
    useEffect(function () {
        if (selection) {
            var deterministic = mergedOptions.deterministic, fontFamily = mergedOptions.fontFamily, fontStyle = mergedOptions.fontStyle, fontSizes = mergedOptions.fontSizes, fontWeight = mergedOptions.fontWeight, padding = mergedOptions.padding, rotations_1 = mergedOptions.rotations, rotationAngles_1 = mergedOptions.rotationAngles, spiral = mergedOptions.spiral, scale_1 = mergedOptions.scale;
            var sortedWords_1 = words
                .concat()
                .sort(function (x, y) { return descending(x.value, y.value); })
                .slice(0, maxWords);
            var random_1 = deterministic ? seedrandom('deterministic') : seedrandom();
            var layout_1 = cloud()
                .size(size)
                .padding(padding)
                .words(sortedWords_1)
                .rotate(function () {
                if (rotations_1 === undefined) {
                    // default rotation algorithm
                    return (~~(random_1() * 6) - 3) * 30;
                }
                else {
                    return rotate(rotations_1, rotationAngles_1, random_1);
                }
            })
                .spiral(spiral)
                .random(random_1)
                .text(getText)
                .font(fontFamily)
                .fontStyle(fontStyle)
                .fontWeight(fontWeight);
            var draw_1 = function (fontSizes, attempts) {
                if (attempts === void 0) { attempts = 1; }
                layout_1
                    .fontSize(function (word) {
                    var fontScale = getFontScale(sortedWords_1, fontSizes, scale_1);
                    return fontScale(word.value);
                })
                    .on('end', function (computedWords) {
                    /** KNOWN ISSUE: https://github.com/jasondavies/d3-cloud/issues/36
                     * Recursively layout and decrease font-sizes by a SHRINK_FACTOR.
                     * Bail out with a warning message after MAX_LAYOUT_ATTEMPTS.
                     */
                    if (sortedWords_1.length !== computedWords.length &&
                        attempts <= MAX_LAYOUT_ATTEMPTS) {
                        if (attempts === MAX_LAYOUT_ATTEMPTS) {
                            console.warn("Unable to layout " + (sortedWords_1.length -
                                computedWords.length) + " word(s) after " + attempts + " attempts.  Consider: (1) Increasing the container/component size. (2) Lowering the max font size. (3) Limiting the rotation angles.");
                        }
                        var minFontSize = Math.max(fontSizes[0] * SHRINK_FACTOR, 1);
                        var maxFontSize = Math.max(fontSizes[1] * SHRINK_FACTOR, minFontSize);
                        draw_1([minFontSize, maxFontSize], attempts + 1);
                    }
                    else {
                        render(selection, computedWords, mergedOptions, mergedCallbacks, random_1);
                    }
                })
                    .start();
            };
            draw_1(fontSizes);
        }
    }, [maxWords, mergedCallbacks, mergedOptions, selection, size, words]);
    return React.createElement("div", { ref: ref });
}
Wordcloud.defaultProps = {
    callbacks: defaultCallbacks,
    maxWords: 100,
    minSize: [300, 300],
    options: defaultOptions,
};

export default Wordcloud;
export { Scale, Spiral, defaultCallbacks, defaultOptions };
